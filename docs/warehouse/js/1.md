# 高频实现

> 陆续会完善每个方法的输入输出，基本参数

## push <Badge type="tip" text="Js" vertical="middle" /> <Badge type="warning" text="Ts" vertical="middle" />

`push() `方法可向数组的末尾添加一个或多个元素，并返回新的长度。

<CodeGroup>
  <CodeGroupItem title="Js" active>

```js
// by 余光
Array.prototype._push = function () {
  const arr = this;
  const len = arr.length;
  const args = arguments;
  for (let i = 0; i < args.length; i++) {
    arr[len + i] = args[i];
  }
  return arr.length;
};

// by zy
Array.prototype._push = function () {
  const arr = this;
  const len = arr.length;
  for (let i = 0; i < arguments.length; i++) {
    arr[len + i] = arguments[i];
  }
  return arr.length;
};
```

  </CodeGroupItem>

  <CodeGroupItem title="Ts" >

```ts
// 余光
function _push(arr: Array<any>, ...arg: Array<any>) {
  const len = arr.length;
  for (let i = 0; i < arg.length; i++) {
    arr[len + i] = arg[i];
  }
  return arr.length;
}
```

  </CodeGroupItem>
</CodeGroup>

总结：思路基本一致，都是将参数循环添加到数组的末尾

## pop <Badge type="tip" text="Js" vertical="middle" />
`pop() ` 删除数组最后一项，并返回被删除的值

```js
// by 余光
Array.prototype._pop = function () {
  const arr = this;
  const res = arr[arr.length - 1];
  arr.length = arr.length - 1;
  return res;
};

// by zy
Array.prototype._pop = function () {
  const arr = this;
  const result = arr[arr.length - 1];
  arr.length = arr.length - 1;
  return result;
};
```

## Every <Badge type="tip" text="Js" vertical="middle" />
对数组每项都运行传入的函数，如果对每项函数都返回true，则这个方法返回true


```js
// by 余光
Array.prototype._every = function (callback, target = this) {
  const arr = target;
  const len = arr.length;

  if (typeof callback != "function") {
    throw new Error(); // 这里参考zy的分析，添加参数兼容会比较好
  }
  if (len === 0) return []; // 如果为空数组，返回[]

  for (let i = 0; i < len; i++) {
    if (!callback(arr[i], i, arr)) {
      return false;
    }
  }
  return true;
};

// by zy
Array.prototype._every = function (cb, thisValue = this) {
  if (typeof cb != "function") {
    throw new Error();
  }
  if (thisValue.length == 0) {
    return true;
  }
  for (let i = 0; i < thisValue.length; i++) {
    if (!cb(thisValue[i], i, thisValue)) {
      return false;
    }
  }
  return true;
};
```

## some <Badge type="tip" text="Js" vertical="middle" />
对数组每项都运行传入的函数，如果有一项返回true，则这个方法返回true


```js
// by 余光
Array.prototype._some = function (callback, target = this) {
  const arr = target;
  const len = arr.length;

  if (len === 0) return []; // 如果为空数组，返回[]

  for (let i = 0; i < len; i++) {
    if (callback(arr[i], i, arr)) {
      return true;
    }
  }
  return false;
};

// by zy
Array.prototype._some = function (cb, thisValue = this) {
  if (typeof cb != "function") {
    throw new Error();
  }
  if (thisValue.length == 0) {
    return false;
  }
  for (let i = 0; i < thisValue.length; i++) {
    if (cb(thisValue[i], i, thisValue)) {
      return true;
    }
  }
  return false;
};
```

## filter <Badge type="tip" text="Js" vertical="middle" />
对数组每项都运行传入的函数，函数返回true的项组成数组之后返回。


```js
// by 余光
Array.prototype._filter_ = function (callback, target = this) {
  const arr = target; // 保存this
  const result = []; // 返回新数组
  const len = arr.length;

  if (len === 0) return []; // 如果为空数组，返回[]

  for (let i = 0; i < len; i++) {
    if (callback(arr[i], i, arr)) result.push(arr[i]); //如果判定条件为true，保存至新数组
  }
  return result; // 返回符合条件的结果
};

// by zy
Array.prototype._filter = function (cb, thisValue = this) {
  const result = [];
  if (typeof cb != "function") {
    throw new Error();
  }
  if (thisValue.length == 0) {
    return [];
  }
  for (let i = 0; i < thisValue.length; i++) {
    if (cb(thisValue[i], i, thisValue)) {
      result.push(thisValue[i]);
    }
  }
  return result;
};
```

## forEach <Badge type="tip" text="Js" vertical="middle" />
对数组每项都运行传入的函数，无返回值。

```js
// by 余光
Array.prototype._forEach = function (callback, target = this) {
  const arr = target; // 保存this
  const result = []; // 返回新数组
  const len = arr.length;

  if (len === 0) return []; // 如果为空数组，返回[]
  for (let i = 0; i < len; i++) {
    callback(arr[i], i, arr);
  }
  return; // 返回undefined
};

// by zy
Array.prototype._forEach = function (cb, thisValue = this) {
  const result = [];
  if (typeof cb != "function") {
    throw new Error();
  }
  if (thisValue.length == 0) {
    return;
  }
  for (let i = 0; i < thisValue.length; i++) {
    cb(thisValue[i], i, thisValue);
  }
  return;
};
```

## 深浅拷贝 <Badge type="tip" text="Js" vertical="middle" />

```js
// by zy
function shallowCopy(target) {
  if (typeof target === "object" && target != null) {
    const copy = target instanceof Array ? [] : {};
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        copy[key] = target[key];
      }
    }
    return copy;
  }
  return target;
}

function deepCopy(target) {
  if (typeof target === "object" && target != null) {
    const copy = target instanceof Array ? [] : {};
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        copy[key] =
          typeof target[key] === "object"
            ? deepClone(target[key])
            : target[key];
      }
    }
    return copy;
  }
  return target;
}

// by 余光
function shallowCopy(target) {
  //
  if (typeof target === "object" && target != null) {
    const copy = target instanceof Array ? [] : {};
    for (let key in target) {
      if (target.hasOwnProperty(key)) {
        copy[key] = target[key];
      }
    }
    return copy;
  }
  return target;
}
```

## flat <Badge type="tip" text="Js" vertical="middle" />

**描述**

flat() 方法会按照一个可指定的深度递归遍历数组，并将所有元素与遍历到的子数组中的元素合并为一个新数组返回。

```js
// by 余光
// 递归方式
Array.prototype._flat = function (deep = 1) {
  // 获取调用者
  let arr = this;
  // 拍平层数校验
  if (deep < 1) return arr;
  //
  return arr.reduce(
    (prev, next, i, n) => [
      ...prev,
      ...(Array.isArray(next) ? next._flat(deep - 1) : [next]),
    ],
    []
  );
};

//zy
Array.prototype.myFlat = function (num = 1) {
  if (num < 0) return this;
  let arr = [];
  this.forEach(item => {
    if (Array.isArray(item)) {
      arr = arr.concat(item.myFlat(--num));
    } else {
      arr.push(item);
    }
  });
  return arr;
};
```

## bind <Badge type="tip" text="Js" vertical="middle" />

**描述**

> bind() 方法创建一个新的函数，在`bind()`被调用时，这个新函数的`this`被指定为`bind()`的第一个参数，而其余参数将作为新函数的参数，供调用时使用。

```js
// by 余光
Function.prototype._bind = function (context, ...arg) {
  var self = this;
  const fBound = function (...childArg) {
    return self.apply(context, arg.concat(childArg)); // 拼接参数
  };
  fBound.prototype = this.prototype; // 连接原型链
  return fBound;
};
//zy
Function.prototype.myBind = function (context = window,...args){
  const fn = this;
  let newFn =  function (...secondArgs){
    fn.call(this,...args,...secondArgs)
  }
  newFn.prototype = this.prototype;
  return newFn;
}
```

## call <Badge type="tip" text="Js" vertical="middle" />

使用一个指定的 this 值和单独给出的一个或多个参数来调用一个函数

> 第一个参数指定了函数体内 this 对象的指向
> 第二个参数及以后为函数调用的参数

```js
// 余光
Function.prototype._bind = function (obj, ...arg) {
  if (typeof this !== "function") {
    throw new Error("what is trying to be bound is not callable");
  }
  const obj = obj || window; // 兼容参数
  obj.func = this; // 将函数变成对象的内部属性

  const result = obj.func(...arg); // 执行函数
  delete obj.func; // 删除函数，当做什么都没发生～
  return result;
};
//zy
Function.prototype.myCall= function(context = window,...args){
  const key = Symbol() // 防止覆盖原有属性
  context[key] = this;
  const result = context[key](...args);
  delete context[key];
  return result;
}

```

## apply <Badge type="tip" text="Js" vertical="middle" />

> 第一个参数指定了函数体内 this 对象的指向
> 第二个参数为函数调用的参数数组

```js
// 余光
Function.prototype._bind = function (obj, arg) {
  if (typeof this !== "function") {
    throw new Error("what is trying to be bound is not callable");
  }
  const obj = obj || window; // 兼容参数
  obj.func = this; // 将函数变成对象的内部属性

  const result = obj.func(...arg); // 执行函数
  delete obj.func; // 删除函数，当做什么都没发生～
  return result;
};

//zy
Function.prototype.myApply = function(context = window,args){
  const key = Symbol() // 防止覆盖原有属性
  context[key] = this;
  const result = context[key](...args);
  delete context[key];
  return result;
}

```
